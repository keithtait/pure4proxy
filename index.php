<?php

/**
 * Pure 4 XML Proxy
 * 
 * The XML feeds generated by Pure 4 cannot be parsed Squiz Matrix due to the presence of additional elements.
 * This program transposes the generated feed into a friendly barebones structure with attributes and empty elements removed
 * 
 * @author Keith Tait <keith.tait@ed.ac.uk>
 * @since 22 Feb 2013
 *
 * Config
 * 
 * @param array $containers         the parents of the nodes we want to extract
 * @param source $source            the remote XML
 * @param string $namespace         gives us access to the $containers
 * @global string $next_node_id     global variable used to add an 'id' field to each stored node, set to 1 by default
 * @param array $node_list          an array to hold the stored nodes      
 */ 
$containers = '//core:renderedItem';
$source = 'http://www.sps.ed.ac.uk/__data/assets/xml_file/0003/97248/clippings.xml';
$namespace = 'http://atira.dk/schemas/pure4/model/core/stable';
$next_node_id = '1';
$node_list = array();

/**
 * If the remote XML file exists do the do
 * 
 * Load the remote file into an new SimpleXML object
 * Set the starting element relative to the namespace
 * Manually create new root node
 * Traverse the incoming XML and store each node
 * Create an error message if no additional nodes have been stored otherwise generate the XML
 * Set the mime-type, add a doctype declaration and display the generated XML
 */
if (remote_file_exist($source))
{
    $input = new SimpleXMLElement($source, null, true);
    
    $root = $input->children($namespace);
    
    $node_list = add_to_node_list($node_list, array(
        'id' => '1',
        'parent_id' => '0',
        'tag' => 'div',
        'attributes' => '',
        'content' => '',
        'level' => '0',
        'has_children' => true
        ));
        
    $next_node_id++;
    
    foreach ($root->xpath($containers) as $container)
    {       
        foreach ($container->children() as $element)
        {
            $id = $next_node_id;
            $level = '1';
            $parent_id = '1';
            
            $node_list = store_node($element, $id, $parent_id, $level, $node_list);
        }
    }

    if ( ! count($node_list) > 1)
    {
        $output = build_error_message('The request did not return any results');
    }
    else
    {
        $output = build_xml($node_list, $node_list[0], $xml = null);
    }    
}

header('Content-type: application/xml');
echo '<?xml version="1.0" encoding="UTF-8"?>'."\n"; 
echo $output;

/**
 * Add a newly created node to the node list
 *
 * @param array $node_list
 * @param array $new_node
 * @return array $node_list
 */
function add_to_node_list($node_list, $new_node)
{        
    array_push($node_list, $new_node);
    
    return $node_list;
}

/**
 * Create an error message in the form of an XML element
 *
 * @param string $message
 * @return string $error
 */
function build_error_message($message)
{
    $error = open_tag(array(
        'tag' => 'div',
        'attributes' => 'class="error"',
        ));

    $error .= $message;

    $error .= close_tag(array(
        'tag' => 'div',
    ));
    
    return $error;
}

/**
 * Generate XML from the node list by navigating via the ids and parent ids
 *
 * @param array $node_list
 * @param array $node
 * @param string $xml
 * @return string $xml
 */
function build_xml($node_list, $node, $xml)
{       
    $xml .= open_tag($node);

    if ($children = get_child_nodes($node_list, $node['id']))
    {
        $xml .= "\n";

        foreach ($children as $child)
        {
            $xml = build_xml($node_list, $child, $xml);
        }
    }
    else
    {
        $xml .= $node['content'];
    }

    $xml .= close_tag($node)."\n";   
        
    return $xml;
}

/**
 * Create the markup for an element closing tag
 *
 * @param array $node
 * @param string $tag
 */
function close_tag($node)
{
     $tag = '</'.$node['tag'].'>';
     
     return $tag;
}

/**
 * Retrieve the attributes from an XML element
 *
 * @param array $element
 * @return string $attributes
 */
function get_attributes($element)
{
    $attributes = '';
    
    foreach ($element->attributes() as $key => $value)
    {
        $attributes .= $key.'="'.$value.'"';
    }
    
    return $attributes;
}

/**
 * Retrieve an array of children nodes
 *
 * @param array $node_list
 * @param string $node_id
 * @return mixed $children Could be $children could be false
 */
function get_child_nodes($node_list, $node_id)
{
    $children = array();
    
    foreach ($node_list as $node)
    {
        if ($node['parent_id'] == $node_id)
        {
            $children[] = $node;
        }
    }
    
    return (count($children)) ? $children : false;
}

/**
 * Check to see if a node is already in the node list
 *
 * @param array $node_list 
 * @param string $node_id
 * @return bool $result
 */
function in_node_list($node_list, $node_id)
{
    $result = false;
    
    foreach ($node_list as $node)
    {
        if ($node['id'] == $node_id)
        {
            $result = true;
        }
    }

    return $result;
}

/**
 * Create the markup for an element opening tag
 *
 * @param array $node
 * @param string $tag
 */
function open_tag($node)
{
    $attributes = ($node['attributes']) ? ' '.$node['attributes'] : '';
    
    $tag = '<'.$node['tag'].$attributes.'>';
    
    return $tag;
}

/**
 * Check to see if the remote XML file exists
 *
 * @param array $url
 * @return bool $result
 */
function remote_file_exist($url)
{
    $headers = @get_headers($url);
    
    $result = (strpos($headers[0],'200') === false) ? false : true;
    
    return $result;
}

/**
 * Store the passes XML element as a node in the node list
 *
 * @param array $element
 * @param string $id
 * @param string $parentid
 * @param string $level
 * @param array $node_list
 * @global string $next_node_id
 * @return array $node_list
*/
function store_node($element, $id, $parent_id, $level, $node_list)
{
    global $next_node_id;
    
    $node = array(
        'id' => $id,
        'parent_id' => $parent_id,
        'tag' => $element->getName(),
        //'attributes' => get_attributes($element),
        'attributes' => '',
        'content' => trim((string)$element),
        'level' => $level,
        'has_children' => false,
    );
    
    if (count($element->children()))
    {
        $node['has_children'] = true;
    }
    
    if (( ! in_node_list($node_list, $node['id'])) AND (strlen($element)))
    {
        $node_list = add_to_node_list($node_list, $node);
        $next_node_id++;
    }
    
    foreach ($element->children() as $child)
    {
        $child_id = $next_node_id;
        $child_level = $node['level'] + 1;
        $child_parent_id = $node['id'];

        $node_list = store_node($child, $child_id, $child_parent_id, $child_level, $node_list);
    }

    return $node_list;
}

?>